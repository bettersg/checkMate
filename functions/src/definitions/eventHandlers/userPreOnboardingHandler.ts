import { onMessagePublished } from "firebase-functions/v2/pubsub"
import { logger } from "firebase-functions"
import * as admin from "firebase-admin"
import { Timestamp, FieldValue } from "firebase-admin/firestore"
import {
  sendOnboardingFlow,
  sendLanguageSelection,
  sendCheckMateUsagePrompt,
  sendCheckMateDemonstration,
  sendUnsupportedTypeMessage,
} from "../../definitions/common/responseUtils"
import { normalizeSpaces, checkPreV2User } from "../../definitions/common/utils"
import { sendWhatsappTextMessage } from "../../definitions/common/sendWhatsappMessage"
import {
  WhatsappMessageObject,
  LanguageSelection,
  GeneralMessage,
} from "../../types"
import { determineNeedsChecking } from "../../definitions/common/machineLearningServer/operations"
import { publishToTopic } from "../../definitions/common/pubsub"
import { getUserSnapshot } from "../../services/user/userManagement"

if (!admin.apps.length) {
  admin.initializeApp()
}

const INSTRUCTION_MESSAGE =
  "Tap one of these below to simulate sending a message in for checking👇"
const PREPOPULATED_MESSAGE = "Show me how to use CheckMate"

const SAMPLE_MESSAGES = [
  {
    message:
      "Your Apple ID Has Been Disabled Pending Further Verification #86359110",
    response: `🚨 This is a scam. The message claiming your Apple ID is disabled is a phishing attempt. It uses unusual characters and formatting, which are red flags. Legitimate companies like Apple communicate clearly and professionally, directing users to official channels for verification. Do not click on any links or provide personal information in response to this message.

☝️This response was generated by AI on 02 Mar 2025.`,
    language: "en",
  },
  {
    message:
      "您的电话号码在我的通讯录里，请问我们是不是在哪里见过？相互留下了电话号码？",
    response: `🚨 这是一个骗局。此信息是一种常见的策略，用于引导收件人进行对话，通常会导致试图获取个人信息或金钱。如果您不认识发件人，请不要回复，并考虑屏蔽该号码以保护自己免受潜在的欺诈。

☝️此回复由人工智能于30 Mar 2025撰写。`,
    language: "cn",
  },
  {
    message:
      "Fm a friend: hearsay hitting yr elbow can save one from heart attack",
    response: `❌ This is largely untrue. The claim that hitting or tapping your elbow can prevent or help recover from a heart attack lacks scientific evidence. Heart attacks are caused by blockages in blood supply, and tapping the elbow does not address this issue. Traditional Chinese medicine may mention tapping for circulation, but it does not support this claim. In case of a heart attack, CPR is the recommended action, not tapping the elbow.

☝️This response was generated by AI on 30 Mar 2025.`,
    language: "en",
  },
  {
    message: "https://signup.redeem.gov.sg/",
    response: `✅ This is a legitimate government site. The link leads to a website with the 'gov.sg' domain, reserved for official Singapore government websites. It provides information on CDC Vouchers 2025 and Climate Vouchers, both government initiatives. The site is managed by GovTech Singapore, confirming its authenticity.

☝️This response was generated by AI on 30 Mar 2025.`,
    language: "en",
  },
]

/**
 * Handles pre-onboarded user messages
 */
async function handlePreOnboardedMessage(
  userSnap: admin.firestore.DocumentSnapshot,
  message: WhatsappMessageObject
) {
  let step
  let shouldProcessJourney = true

  try {
    if (userSnap.get("numPreOnboardSubmissionsRemaining") <= 0) {
      await sendOnboardingFlow(userSnap, false)
      step = "preonboard_limit_reached"
    } else {
      switch (message.type) {
        case "text":
          step = "preonboard_open"
          //if no text, throw error
          const text = message.text?.body
          if (!text) {
            throw new Error("No text in message")
          }
          if (text === PREPOPULATED_MESSAGE) {
            step = "preonboard_prepopulated"
            //wait 5 seconds before sending onboarding flow
            await sendCheckMateDemonstration(userSnap)
            break
          }
          if (text === INSTRUCTION_MESSAGE) {
            step = "preonboard_wrong_message"
            await sendCheckMateUsagePrompt(userSnap, true, true, true)
            break
          }
          if (await respondToSampleMessage(message, userSnap)) {
            step = "preonboard_sample"
            //wait 5 seconds before sending onboarding flow
            await new Promise((resolve) => setTimeout(resolve, 5000))
            await sendOnboardingFlow(userSnap, true)
            break
          }
          const needsChecking = await determineNeedsChecking({
            text: text,
          })
          if (!needsChecking) {
            step = "preonboard_trivial"
            if (userSnap.get("numPreOnboardMessagesSent") > 0) {
              await sendCheckMateUsagePrompt(userSnap, true)
            } else {
              await sendLanguageSelection(userSnap, true)
            }
            break
          }

          // Non-trivial message that needs checking
          step = "preonboard_needs_checking"
          await createAndPublishMessage(message, userSnap)
          break

        case "image":
          step = "preonboard_image"
          await createAndPublishMessage(message, userSnap)
          break

        case "interactive":
          const interactive = message.interactive
          if (!interactive) {
            logger.error("Message has no interactive object")
            break
          }
          switch (interactive.type) {
            case "button_reply":
              step = await onPreOnboardButtonReply(userSnap, message)
              break
          }
          break
        default:
          step = "preonboard_unsupported"
          await sendUnsupportedTypeMessage(userSnap, message.id)
          await sendCheckMateUsagePrompt(userSnap, false)
          break
      }
    }
    await userSnap.ref.update({
      numPreOnboardMessagesSent: FieldValue.increment(1),
    })
  } catch (error) {
    logger.error(`Error in handlePreOnboardedMessage: ${error}`)
  } finally {
    // Check if we should update the journey log
    if (checkPreV2User(userSnap)) {
      shouldProcessJourney = false
    }

    if (shouldProcessJourney && step) {
      const messageTimestamp = new Timestamp(Number(message.timestamp), 0)
      const timestampKey =
        messageTimestamp.toDate().toISOString().slice(0, -5) + "Z"

      await userSnap.ref.update({
        [`initialJourney.${timestampKey}`]: step,
      })
    }
  }
}

/**
 * Creates a GeneralMessage object and publishes it to the userNavigationEvents topic
 */
async function createAndPublishMessage(
  message: WhatsappMessageObject,
  userSnap: admin.firestore.DocumentSnapshot
) {
  //convert message to general Message object for processing
  let genericMessage: GeneralMessage = {
    source: "whatsapp",
    id: message.id,
    userId: message.from,
    isUserOnboarded: userSnap.get("isOnboardingComplete"),
    type: message.type,
    subject: null,
    text: message.text?.body ?? null,
    media: {
      fileId: message.image?.id ?? null, //to download the media
      caption: message.image?.caption ?? null,
      mimeType: message.image?.mime_type ?? null, //determines if it is an image or video
    },
    timestamp: message.timestamp,
    isForwarded: message.context?.forwarded,
    frequently_forwarded: message.context?.frequently_forwarded,
  }

  await publishToTopic("userGenericMessages", genericMessage, "whatsapp")
}

/**
 * Handles button replies from pre-onboarded users
 */
async function onPreOnboardButtonReply(
  userSnap: admin.firestore.DocumentSnapshot,
  messageObj: WhatsappMessageObject
) {
  const buttonId = messageObj.interactive?.button_reply.id
  if (!buttonId) {
    logger.error("No buttonId in interactive object")
    return
  }
  const [type, ...rest] = buttonId.split("_")
  let selection
  switch (type) {
    case "show":
      await sendCheckMateDemonstration(userSnap)
      break
    case "signup":
      await sendOnboardingFlow(userSnap, false)
      break
    case "languageSelection":
      ;[selection] = rest as [LanguageSelection]
      await userSnap.ref.update({
        language: selection,
      })
      await sendCheckMateUsagePrompt(userSnap, false)
      break
  }
  const step = "preonboard_button_" + type + (selection ? `_${selection}` : "")
  return step
}

/**
 * Checks if the message matches any sample messages and sends the appropriate response
 */
async function respondToSampleMessage(
  message: WhatsappMessageObject,
  userSnap: admin.firestore.DocumentSnapshot
) {
  if (!message.text?.body) {
    throw new Error("No text in message")
  }
  const textNormalised = normalizeSpaces(message.text?.body).toLowerCase()

  for (const sample of SAMPLE_MESSAGES) {
    const sampleNormalised = normalizeSpaces(sample.message).toLowerCase()
    if (textNormalised === sampleNormalised) {
      await sendWhatsappTextMessage(
        "user",
        userSnap.get("whatsappId"),
        sample.response
      )
      if (sample.language !== userSnap.get("language")) {
        await userSnap.ref.update({
          language: sample.language,
        })
      }
      return true
    }
  }
  return false
}

const onUserPreOnboardingPublish = onMessagePublished(
  {
    topic: "userPreOnboardingEvents",
    secrets: [
      "WHATSAPP_USER_BOT_PHONE_NUMBER_ID",
      "WHATSAPP_CHECKERS_BOT_PHONE_NUMBER_ID",
      "WHATSAPP_TOKEN",
      "VERIFY_TOKEN",
      "TYPESENSE_TOKEN",
      "OPENAI_API_KEY",
    ],
    timeoutSeconds: 120,
  },
  async (event) => {
    if (event.data.message.json) {
      logger.log(`Processing ${event.data.message.messageId}`)

      try {
        const message = event.data.message.json as WhatsappMessageObject
        const userSnap = await getUserSnapshot(message.from, "whatsapp")
        if (userSnap && message) {
          await handlePreOnboardedMessage(userSnap, message)
          logger.log(
            `Successfully processed pre-onboarding message ${message.id}`
          )
        } else {
          logger.error("Missing required data in message payload")
        }
      } catch (error) {
        logger.error(`Error processing pre-onboarding message: ${error}`)
      }
    } else {
      logger.warn(
        `Unknown message type for messageId ${event.data.message.messageId})`
      )
    }
  }
)

export { onUserPreOnboardingPublish }
